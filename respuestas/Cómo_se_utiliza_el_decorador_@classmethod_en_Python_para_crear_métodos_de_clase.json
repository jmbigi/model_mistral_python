{
  "question": "¿Cómo se utiliza el decorador @classmethod en Python para crear métodos de clase?",
  "answer": "\nEl decorador `@classmethod` es una forma de crear métodos de clase sin necesitar instanciar el objeto. Esto se hace en Python mediante la siguiente sintaxis:\n```python\n@classmethod\ndef nombre_del_metodo(self, *args, **kwargs):\n    # Código del método\n```\nEn esta sintaxis, `nombre_del_metodo` es el nombre de la función que se va a crear como método de clase. El parámetro `self` se utiliza para referirse al objeto en sí mismo y los argumentos `*args` y `**kwargs` son opcionales y utilizados para pasar varios parámetros a la función.\n\nLa función que se va a crear como método de clase debe tener un nombre de `nombre_del_metodo`, pero no es obligatorio especificar el tipo de función que se va a crear, ya sea una función clásica o una función de clase.\n\nPor ejemplo, si tenemos la siguiente función:\n```python\ndef suma(x, y):\n    return x + y\n```\nPodemos convertirla en un método de clase mediante el decorador `@classmethod`:\n```python\n@classmethod\ndef suma(cls, x, y):\n    return cls.resultado + x + y\n\nclass Calculadora:\n    resultado = 0\n\ncalculadora = Calculadora()\n\nprint(calculadora.suma(2, 3))  # Output: 7\n```\nEn este ejemplo, la función `suma` se ha convertido en un método de clase mediante el decorador `@classmethod`. El método se llama `suma` y utiliza una instancia de la clase `Calculadora` para agregar los parámetros `x` y `y`. La función retorna el valor de `resultado + x + y`, lo que es el resultado de la suma.\n\nEl parámetro `self` se utiliza en esta función para referirse a la instancia de la clase `Calculadora` y no se necesita especificar su tipo, ya sea una función clásica o una función de clase."
}